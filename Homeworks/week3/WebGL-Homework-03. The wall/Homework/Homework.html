<!DOCTYPE html>

<head>
	<meta charset="utf-8"/>
	<title>Стената</title>

	<script src="webgl-fmi.js"></script>	
	
	<script id="vshader" type="x-shader/x-vertex">
		uniform mat4 uProjectionMatrix;
		uniform mat4 uViewMatrix;
		uniform mat4 uModelMatrix;
		attribute vec3 aXYZ;
		void main ()
		{
			gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aXYZ,1);
		}
	</script>
	
	<script id="fshader" type="x-shader/x-fragment">
		precision mediump float;
		uniform vec3 uColor;
		void main( )
		{
			gl_FragColor = vec4(uColor,1);
		}
	</script>

	<script>
		var cameraAngleX = 0.7;
		var cameraAngleY = 0.5;
		var isDragging = false;
		var lastMouseX = 0;
		var lastMouseY = 0;
		
		var bufLines, bufFaces;
		
		function start( )
		{
			gl = getContext("picasso");
			glprog = getProgram("vshader","fshader");
			
			aXYZ = gl.getAttribLocation(glprog,"aXYZ");
			uColor = gl.getUniformLocation(glprog,"uColor");
			uProjectionMatrix = gl.getUniformLocation(glprog,"uProjectionMatrix");
			uViewMatrix = gl.getUniformLocation(glprog,"uViewMatrix");
			uModelMatrix = gl.getUniformLocation(glprog,"uModelMatrix");

			gl.clearColor(1,1,1,1);
			gl.clear(gl.COLOR_BUFFER_BIT);

			var proj = perspMatrix(30,gl.canvas.width/gl.canvas.height,1,40000);
			gl.uniformMatrix4fv(uProjectionMatrix,false,proj);

			var dataLines = [ 0.5,-0.5,0.5, 0.5,0.5,0.5, -0.5,0.5,0.5, -0.5,-0.5,0.5,
							 0.5,-0.5,-0.5, 0.5,0.5,-0.5, -0.5,0.5,-0.5, -0.5,-0.5,-0.5,
							 0.5,-0.5,0.5, 0.5,-0.5,-0.5, 0.5,0.5,0.5, 0.5,0.5,-0.5,
							-0.5,0.5,0.5, -0.5,0.5,-0.5, -0.5,-0.5,0.5, -0.5,-0.5,-0.5];
			
			var dataFaces = [
				-0.5,-0.5,0.5, 0.5,-0.5,0.5, 0.5,0.5,0.5,
				-0.5,-0.5,0.5, 0.5,0.5,0.5, -0.5,0.5,0.5,
				-0.5,-0.5,-0.5, -0.5,0.5,-0.5, 0.5,0.5,-0.5,
				-0.5,-0.5,-0.5, 0.5,0.5,-0.5, 0.5,-0.5,-0.5,
				-0.5,0.5,-0.5, -0.5,0.5,0.5, 0.5,0.5,0.5,
				-0.5,0.5,-0.5, 0.5,0.5,0.5, 0.5,0.5,-0.5,
				-0.5,-0.5,-0.5, 0.5,-0.5,-0.5, 0.5,-0.5,0.5,
				-0.5,-0.5,-0.5, 0.5,-0.5,0.5, -0.5,-0.5,0.5,
				 0.5,-0.5,-0.5, 0.5,0.5,-0.5, 0.5,0.5,0.5,
				 0.5,-0.5,-0.5, 0.5,0.5,0.5, 0.5,-0.5,0.5,
				-0.5,-0.5,-0.5, -0.5,-0.5,0.5, -0.5,0.5,0.5,
				-0.5,-0.5,-0.5, -0.5,0.5,0.5, -0.5,0.5,-0.5
			];
			
			bufLines = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER,bufLines);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dataLines), gl.STATIC_DRAW);
			
			bufFaces = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER,bufFaces);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dataFaces), gl.STATIC_DRAW);
			
			gl.enableVertexAttribArray(aXYZ);
			gl.vertexAttribPointer(aXYZ,3,gl.FLOAT,false,0,0);

			gl.canvas.addEventListener('mousedown', function(e) {
				isDragging = true;
				lastMouseX = e.clientX;
				lastMouseY = e.clientY;
			});
			
			gl.canvas.addEventListener('mousemove', function(e) {
				if (isDragging) {
					var dx = e.clientX - lastMouseX;
					var dy = e.clientY - lastMouseY;
					cameraAngleX += dx * 0.01;
					cameraAngleY += dy * 0.01;
					cameraAngleY = Math.max(-1.5, Math.min(1.5, cameraAngleY));
					lastMouseX = e.clientX;
					lastMouseY = e.clientY;
					updateCamera();
				}
			});
			
			gl.canvas.addEventListener('mouseup', function() { isDragging = false; });
			gl.canvas.addEventListener('mouseleave', function() { isDragging = false; });
			
			updateCamera();
		}
		
		function updateCamera()
		{
			var radius = 5;
			var eyeX = radius * Math.sin(cameraAngleX) * Math.cos(cameraAngleY);
			var eyeY = radius * Math.sin(cameraAngleY);
			var eyeZ = radius * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
			
			var view = viewMatrix([eyeX, eyeY, eyeZ], [0,0,0], [0,0,1]);
			gl.uniformMatrix4fv(uViewMatrix,false,view);
			
			drawScene();
		}
		
		// Mathematical heart shape using the classic parametric formula
		// x = 16 * sin(t)^3
		// y = 13*cos(t) - 5*cos(2t) - 2*cos(3t) - cos(4t)
		// We scale and invert y for proper orientation
		
		function isInsideHeart(x, y)
		{
			// Use pre-computed heart boundary - just convert to the same coordinate system
			return pointInHeart(x, y);
		}
		
		// Pre-computed heart boundary points
		var heartBoundary = [];
		function initHeartBoundary()
		{
			if (heartBoundary.length > 0) return;
			
			var scale = 0.08;
			
			// Generate heart boundary points
			for (var t = 0; t < Math.PI * 2; t += 0.05)
			{
				var hx = 16 * Math.pow(Math.sin(t), 3);
				var hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
				
				// Convert back to our coordinate system
				heartBoundary.push({x: hx * scale, y: -hy * scale});
			}
		}
		
		function pointInHeart(px, py)
		{
			initHeartBoundary();
			
			// Point in polygon test (ray casting)
			var inside = false;
			
			for (var i = 0, j = heartBoundary.length - 1; i < heartBoundary.length; j = i++)
			{
				var xi = heartBoundary[i].x, yi = heartBoundary[i].y;
				var xj = heartBoundary[j].x, yj = heartBoundary[j].y;
				
				if (((yi > py) != (yj > py)) && 
					(px < (xj - xi) * (py - yi) / (yj - yi) + xi))
				{
					inside = !inside;
				}
			}
			
			return inside;
		}
		
		function drawScene()
		{
			gl.clear(gl.COLOR_BUFFER_BIT);
			
			var brickWidth = 0.12;
			var brickHeight = 0.06;
			var brickDepth = 0.05;
			
			// Grid covers expected heart area
			for (var y = -1.3; y < 1.4; y += brickHeight * 0.85)
			{
				for (var varX = -1.5; varX < 1.5; varX += brickWidth)
				{
					var cx = varX + brickWidth/2;
					var cy = y + brickHeight/2;
					
					if (isInsideHeart(cx, cy))
					{
						var rowIdx = Math.floor((y + 1.3) / (brickHeight * 0.85));
						var colIdx = Math.floor((varX + 1.5) / brickWidth);
						
						identity();
						translate([varX + brickWidth/2, y + brickHeight/2, 0]);
						scale([brickWidth, brickHeight, brickDepth]);
						useMatrix();
						
						// Brick colors - terracotta/brick red
						var shade = 0.55 + 0.4 * ((rowIdx + colIdx) % 3) / 3;
						gl.uniform3f(uColor, shade, shade * 0.65, shade * 0.5);
						
						// Fill
						gl.bindBuffer(gl.ARRAY_BUFFER, bufFaces);
						gl.vertexAttribPointer(aXYZ, 3, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.TRIANGLES, 0, 36);
						
						// Dark outline
						gl.uniform3f(uColor, 0.12, 0.06, 0.04);
						gl.bindBuffer(gl.ARRAY_BUFFER, bufLines);
						gl.vertexAttribPointer(aXYZ, 3, gl.FLOAT, false, 0, 0);
						gl.drawArrays(gl.LINE_LOOP, 0, 4);
						gl.drawArrays(gl.LINE_LOOP, 4, 4);
						gl.drawArrays(gl.LINES, 8, 8);
					}
				}
			}
		}
		
		function isHeartBoundary(x, y, bw, bh)
		{
			// Check if center is inside heart
			if (!isInsideHeart(x, y)) return false;
			
			// Check if any edge is outside (boundary detection)
			var margin = 0.4;
			var leftIn = isInsideHeart(x - bw * margin, y);
			var rightIn = isInsideHeart(x + bw * margin, y);
			var topIn = isInsideHeart(x, y + bh * margin);
			var bottomIn = isInsideHeart(x, y - bh * margin);
			
			return !leftIn || !rightIn || !topIn || !bottomIn;
		}
	</script>	
</head>

<body onload="start()">
	<h2>Стената</h2>
	<p>Влачете с мишката, за да завъртите изгледа</p>

	<noscript>Искаме JavaScript, но няма!</noscript>
	<canvas id="picasso" width="600" height="400" style="border: solid;">
		Искаме canvas, но няма!
	</canvas>
</body>
